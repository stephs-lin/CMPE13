/*
 * File:   Negotiation.c
 * Author: Stephanie Lin
 *
 * Created on June 2, 2019, 4:20 PM
 */


#include <stdio.h>
#include "xc.h"
#include "Negotiation.h"
#include "BOARD.h"


#define mask 0x0001

//typedef struct {
//    uint8_t number;
//    uint8_t hash;
//}NegotiationData;

NegotiationData *secret;
NegotiationData *commitment;
/* >>>>>> NEED TO INCLUDE FILES <<<<<<*/

/**
 * This function implements a one-way hash.  It maps its input, A, 
 * into an image, #a, in a way that is hard to reverse, but easy 
 * to reproduce.
 * @param secret        //A number that a challenger commits to
 * @return hash         //the hashed value of the secret commitment.
 *
 * This function implements the "Beef Hash," a variant of a Rabin hash.
 * The result is ((the square of the input) modulo the constant key 0xBEEF).
 * So, for example, 
 * NegotiationData
 * NegotiationHash(3) == 9
 * NegotiationHash(12345) == 42182
 */
NegotiationData NegotiationHash(NegotiationData secret) {
    int squared;
    int result;
    /* FORMULA: Hash(A) = A^(2)mod 0xBEEF*/
    squared = (secret * secret);
    result = squared % PUBLIC_KEY;
    secret = result;
    return secret;
}

/**
 * Detect cheating.  An accepting agent will receive both a commitment hash
 * and a secret number from the challenging agent.  This function
 * verifies that the secret and the commitment hash agree, hopefully
 * detecting cheating by the challenging agent.
 *
 * @param secret        //the previously secret number that the challenging agent has revealed
 * @param commitment    //the hash of the secret number
 * @return TRUE if the commitment validates the revealed secret, FALSE otherwise
 */
int NegotiationVerify(NegotiationData secret, NegotiationData commitment) {
    NegotiationData hash_result;
    hash_result = NegotiationHash(secret);
    /* CHECK IF HASH FROM SECRET IS EQUAL TO COMMITMENT*/
    if (hash_result != commitment) {
        return STANDARD_ERROR;
    } else {
        return SUCCESS;
    }
}

/**
 * The coin-flip protocol uses random numbers generated by both
 * agents to determine the outcome of the coin flip.
 *
 * The parity of a bitstring is 1 if there are an odd number of one bits,
 *   and 0 otherwise.
 * So, for example, the number 0b01101011 has 5 ones.  If the parity of
 * A XOR B is 1, then the outcome is HEADS.  Otherwise, the outcome is TAILS.
 */
NegotiationOutcome NegotiateCoinFlip(NegotiationData A, NegotiationData B) {
    int result;
    int product;
    int counter = 0;

    /*BIT PARITY OF A XOR B*/
    product = A^B;

    /*BIT SHIFT 1 RIGHT UNTIL 0x00*/
    while (product != 0) {
        /*MASK WITH 0x01 TO CHECK IF LAST BIT IS A 1*/
        result = product & mask;
        if (result == 1) {
            /*UPDATE COUNT EACH TIME LAST BIT IS A 1*/
            counter++;
        } else {
        }
        /*BIT SHIFT 1 RIGHT*/
        product = product >> 1;
    }
    /*MOD TOTAL COUNT OF 1 WITH 2 TO CALCULATE IF NO. OF 1'S IS EVEN OR ODDS*/
    if ((counter % 2) == 1) {
        return HEADS;
    } else {
        return TAILS;
    }
}

